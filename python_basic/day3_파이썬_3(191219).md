191219 파이썬 3

utf-8: universal version

* csv(comma seperate value): 콤마로 구분된

* HTML 문서는 컴퓨터가 보고 이해하기 어렵게 설계되어 있다. 기존 HTML 형식의 문서론 컴퓨터가 이해하기 어려워 새롭게 나온 문서가 XML이다. 컴퓨터가 해석하기 쉽게 나온 것이 XML이다. 

* XML: HTML과 달리 구조화가 잘 되어 있어 컴퓨터가 해석하기 용이

* JSON: 딕셔너리 형태로 정의되어 있는 문서 형식. NO SQL. 파이썬 라이브러리를 활용한 데이터 분석 251p



#### 자료구조

: 자료를 저장 및 관리하는 방법



##### 튜플

* 리스트[]와 비슷 : 몇 가지 점을 제외하곤 리스트와 유사한 자료구조이다. 
* 리스트는 생성, 삭제, 수정 가능 튜플은 변경을 할 수 없음
*  튜플이 있는 이유는 무엇일까? 리스트와 큰 차이가 없어보이는데 튜플이 있어야 하는 이유는?
  * 튜플은 지우는 것도, 변경하는 것도 불가능. 
    :튜플을 사용해야 하는 경우가 간혹 있다. 변경이 안되므로, 데이터가 계속 유지되어야 할 경우 튜플로 만들
* unpacking: 리스트(튜플)의 요소를 여러개의 변수에 할당하는 것
* packing: 변수에 리스트 또는 튜플을 할당하는 것.

```python
a = (3,2,5,6,1)  # 튜플

a=3,2,5,6,1  
# 튜플: ()로 묶지 않아도 튜플로 생성. 가독성 위해 () 써주는 것이 좋다.
a

# 빈 튜플 만들기
a1 = ()

a2 = 5  # 튜플 아니고 정수값을 담고 있는 변수이다.
type(a2)
a2 =5,
type(a2)  # , 붙여주면 튜플이 된다. 값을 1개 저장한 튜플을 정의할 때는 컴마를 써야함

a3 =('john', 25, 180.5, True)  # 리스트처럼 튜플 또한 자료형에 관계없이 데이터를 저장할 수 있다. 


a=range(10)
# list로 만들 때
a = list(range(10))
# tuple로 만들 때
a = tuple(range(10))

# 튜플 < - > 리스트
a=[1,2,3]
a = tuple(a) # 리스트 -> 튜플
list(a) # 튜플 -> 리스트

list('hello')
tuple('hello')


# 패킹
a = [1,2,3] # 리스트 패킹
b = (1,2,3) # 튜플 패킹

x,y=(1,2) 
# 리스트와 마찬가지로 변수의 개수와 요소의 개수가 동일하지 않으면 error

t1 =(1,2,'x','y')

# del t1[0] =>  error
# t1[0] = 5 => error, 튜플 변경 불가

# 삭제와 변경을 제외한 것들은 리스트와 마찬가지로 가능하다.
t1[1:] 
t2=(3,4)
t1+t2 # 더하기 연산 가능
t2*3 # 곱하기 연산 가능
len(t1) # 요소 개수 확인
```



##### 시퀀스 자료형

: 리스트,튜플, range, 문자열 데이터로 연속적으로 표현 가능

* range는 하나의 객체로 존재, 연속형으로 존재 x
  * ragne 연산 불가 => 연속형(리스트, 튜플)으로 바꿔줘야 가능

```python
# 리스트
# 0~90까지 10씩 증가한 값으로 리스트 생성
a = list(range(0,100,10))

# 시퀀스형에 대해 in 연산자 사용 가능
30 in a # a변수(시퀀스형) 안에 30이 있느냐?
100 in a
30 not in a
100 not in a

# 튜플
a = tuple(range(0,100,10))
# 시퀀스형에 대해 in 연산자 사용 가능
30 in a # a변수(시퀀스형) 안에 30이 있느냐?
100 in a
30 not in a
100 not in a

# 문자열
'h' in 'hello python'

# range
100 in range(100)



# + 연산자로 시퀀스형에 대한 자료 연결이가능: 리스트, 문자열, 튜플
a = [1,2]
b = [3,4]
a+b
'hello' + 'hi'
a=(1,2)
b=(3,4)
a+b

# 연속형으로 바꿔줘야 가능해진다.
list(range(0,3))+list(range(3,5)) 
tuple(range(0,3))+tuple(range(3,5))
# list(range(0,3))+tuple(range(3,5)) => 자료형이 다른 경우에는 에러발생

# 'hello'+127 => 문자에 숫자연결 안됨. 에러발생
# 숫자를 문자로 변환하면 가능: str함수 사용해서 같은 타입으로 바꿔주면 된다.
'hello'+str(7)
'hello'+str(3.14)
```



* len(): 시퀀스 자료형에 해당되는 데이터 길이 구하는 함수

```python
a=[1,2,3]
len(a)

a=(1,2,3)
len(a)

len(range(0,3))
len('hello')

hi='안녕'
len(hi) # len은 문자의 개수를 구하는 함수
# utf-8
hi.encode('utf-8')
len(hi.encode('utf-8'))  # utf-8로 encoing했을 때 길이 알고싶을 때
```

* 시퀀스형에 대한 자료 참조: [] 사용

```python
x = 'HI HELLO'
# x[0] -> x.__getitem__(0)
x[0]
# x[10] => index error: 범위를 벗어나서 생기는 error

# 마지막 문자 참조하고 싶을 때
x[len(x)-1]
x[-1]

# 슬라이싱 익숙해져야: 데이터 전처리에 많이 쓰이기 때문에
x[2:-1]
x[2:]
x[1:7:2] 
# 인덱스 1부타 2씩 증가하면서 인덱스 6번까지 가져옴: 증가폭 지정해서 추출 가능
x[:8:2]
x[3::2]
x[::2] # 처음부터 마지막까지 2씩 증가시켜서 추출해라
x[::]  # x 전체를 추출하는 것과 같음
x[0:len(x)] # x
x[:len(x)] # x

x[5:1:-1] # 5,4,3,2까지 추출 가능
x[::-1] # 역순으로 추출

# 튜플도 리스트와 동일


x=range(10)
x[4:7]
list(range(0,7,2))

x="hello world"
x[:10:3] # 'hlwl'


a=list(range(0,91,10))

# list는 자료형 상관없이 저장 가능. 대체할 때도 마찬가지이다.
a[1]=11
a[2:5]=[21,31,'x'] # [0, 11, 21, 31, 'x', 50, 60, 70, 80, 90]

a[1:9:2]=['a','b','c','d']   # list에서 숫자를 문자로도 변경 가능
# -> [0, 'a', 21, 'b', 'x', 'c', 60, 'd', 80, 90]

# 범위 지정해서 삭제하기
del a[2:6]  # 2~5까지 한번에 삭제 -> [0, 'a', 60, 'd', 80, 90]
del a[:5:2] # ['a', 'd', 90]
```





##### 딕셔너리

* 키(Key)와 값(Value)으로 자료를 표현. 값이 무엇인지에 대해 '키'로 표현해주는 것.
* key:vlaue로 표현 사용빈도 높아. Json 포맷이 딕셔러니 포맷과 비슷하다. 무게가 가벼운 자료구조이기 때문에 연산하는데 속도가 빠르다는 장점을 가지고 있다.

  * key value가 여러 쌍으로 구성
  * 컴마로 구분
  * key는 변하지 않는 것을 사용, value는 변하는 값, 변하지않는 값 모두 사용 가능
  * key는 id와 같다. value는 비밀번호 같은 것으로 이해하면 된다.
* 딕셔너리 왜 필요할까?
* 사람에 대한 정의 표현할 때처럼 데이터 간의 대응관계 나타내야 할 때 사용
  * 딕셔너리를 다른 언어에서는 맵, 해쉬라고 부름(자바)

```python
person=[180,70,'O','서울'] # 리스트형으로 저장
# [180, 70, 'O', '서울']
person2={'키':180,'몸무게':70,'혈액형':'O','사는곳':'서울'}
# {'키': 180, '몸무게': 70, '혈액형': 'O', '사는곳': '서울'}

# person2={'키':180,'몸무게','혈액형':'O','사는곳':'서울'} => 값이 없으면 구문 에러(syntax error)
# person2={'키':180, 70,'혈액형':'O','사는곳':'서울'} => 키가 없으면 구문 에러

person2={'키':180,'몸무게':70,'혈액형':'O','사는곳':'서울', '몸무게':80} 
# 키가 중복되면 마지막 자료가 저장

# 키로 문자,숫자(정수,실수)도 사용 가능
# 딕셔너리 값(=value)의 자리에 '리스트'도 올 수 있다
person2={'키':180,'몸무게':70,'혈액형':'O','사는곳':'서울', False:0, 99:'구구',3.14:[3.14,'원주율']} 

# person2={'키':180,'몸무게':70,'혈액형':'O','사는곳':'서울', False:0, 99:'구구',3.14:[3.14,'원주율'],['주소','전번']:'서울,02'} 
# 에러, 딕셔너리 키(key)에는 리스트 올 수 없음


# 딕셔너리 값(value) 자리에는 다양한 자료형(=) 리스트, 튜플, 딕셔너리) 가능
person2={'신장':180,'몸무게':70,'혈액형':'O','사는곳':'서울','취미':{'오전':'수영','오후':'공부'}}

# person2라는 딕셔너리에는 5개의 키,값으로 구성되어 있다. 취미라는 '값(valuse)'에는 2개의 키,값으로 구성되어 있다.
person2={'신장':180,'몸무게':70,'혈액형':'O','사는곳':'서울','취미':{'오전':['수영','야구'],'오후':'공부'}}
# 딕셔너리 안에 딕셔너리, 딕셔너리 안에 딕셔너리 안에 리스트 넣어줄 수 있다. 
# {'신장': 180,'몸무게': 70,'혈액형': 'O', '사는곳': '서울','취미': {'오전': ['수영', '야구'], '오후': '공부'}}


# 빈 딕셔너리 만들기
x = {}  
x = dict() # dict: 딕셔너리 만드는 함수


# 딕셔너리 만들기
# 첫번째 케이스 : dict(키1=값1, 키2=값2,...)
per = dict(height=180, weight=70, bt='O')
# 딕셔너리 형식으로
per = dict({'height':180, 'weight':70, 'bt':'O'})

# 두번째 케이스: zip함수 사용 (zip 함수 = 1:1로 매칭해주는 함수)
zip(['height','weight','bt'],[180, 70, 'O']) 
# <zip at 0x2ab294a3a48> : zip 함수의 수행 결과가 저장된 공간값
per =dict(zip(['height','weight','bt'],[180, 70, 'O']))

# tuple 형식으로
per = dict([('height',180), ('weight',70), ('bt','O')])
```

```python
# 딕셔너리 활용법

a={1:'hi'} # {1: 'hi'}
a={'a':[1,2,3]} # {'a': [1, 2, 3]}
b={1:'a'} # {1: 'a'}
a[2]='b'  # key:2, value:'b'가 추가됨 -> {'a': [1, 2, 3], 2: 'b'}

a['name']='hgd'
# {'a': [1, 2, 3], 2: 'b', 'name': 'hgd'}

# a에 있는 name 값 바꾸기: 딕셔너리[키]='값'으로 특정 값 변경 가능.
a['name']='lss'
a['weight']=70.5
# {'a': [1, 2, 3], 2: 'b', 'name': 'lss', 'weight': 70.5}


# 딕셔너리에 저장되어 있는 값 중 내가 원하는 키의 값 가져오기
a['name']  # 딕셔너리[키] => 값: name에 해당되는 값(value) 추출 -> lss

# 딕셔너리에 특정 키 있는 지 확인하는 법: in 연산자 이용
'weight' in a
'sky' in a
'sky' not in a

# a라는 딕셔너리 길이 구하기
len(a) # 4


# 키(key) 목록 확인하기
a.keys()
# for문으로 key값 하나씩 다 출력하기
for k in a.keys():
    print(k) 

# 키값 리스트로 출력하기
list(a.keys()) # ['a', 2, 'name', 'weight']


# 값(value) 목록 확인하기
a.values()
for v in a.values():
    print(v)
# value 리스트로 출력하기    
list(a.values()) # [[1, 2, 3], 'b', 'lss', 70.5]


# item: key, value 묶어서 출력하기
for i in a.items():  
    print(i)
# tuple()로 출력
# ('a', [1, 2, 3])
# (2, 'b')
# ('name', 'lss')
# ('weight', 70.5)


# get(키값)으로 키값 있는지 확인하기   
a['name']
a.get('name')
# a['nn'] => key error 발생
print(a.get('nn')) # => None으로 출력됨, None값 출력해서 처리하고 싶을때 씀
# 딕셔너리 a에 nn 키가 없다면 'kim'을 출력해라
a.get('nn','kim') 


a['id']='test'
# 디폴트(기본값) 설정할 때 사용하는 것이 get
a.get('id','guest')
# 특정키 존재하지 않는다면 guest라는 특정값 추출하도록 설정
a.get('id2','guest') 
```





##### set

: 집합(=중복이 허용되지 않는 자료 구조)

* 집합(=중복이 허용되지 않는 자료 구조)
* 순서가 없음
  * x={1,1,2,2,3} => x={1,2,3}
* {}로 나오면 딕셔너리 or set이다. => key,value 쌍으로 구성되어있으면 딕셔너리, 아니면 셋
* []로 나오는 자료형은 리스트이다. ()로 나오는 자료구조는 튜플이다.

```python
s=set([1,2,3,1])

s2=set('hello')
# s2[1] => 순서자리가 없기 때문에 참조가 불가능하다.

# list형, tuple형으로 변환해줘야 참조할 수 있다. 
s = set(['k','i','m'])
slist=list(s) # ['m', 'k', 'i']
slist[1] # k

s = tuple(['k','i','m']) # ('k', 'i', 'm')
s[1] # i

# set에서 데이터 추가하기

s=set([1,2])
s.add(3)
# s.add(4,5) => add 함수는 2개 이상 추가 안됨

# update 함수 사용해서 여러개 추가
s.update([4,5])


# 집합 연산
s1=set([1,2,3,4])
s2=set([5,6,3,4])

# 교집합
s1 & s2
s1.intersection(s2) # == s2.intersection(s1)

# 합집합
s1 | s2
s1.union(s2)

# 차집합
s1-s2
s1.difference(s2)
```

* 수학 함수를 배우는 이유는 뭘까?
   * 편해지기 위해서. 하나하나 코딩해서 교집합 뽑아내지 않고 쉽고 정확하게 하기위해서. 함수를 많이 아는 만큼 시간도 줄어들고 정확한 값을 뽑는 것 가능 
   * 함수는 이미 많은 사람들이 사용하고 있는 검증이 끝난 것이기 때문에 안전하다. 함수를 많이 알고 있는 것이 좋다.





#### 조건문

* 참: "test", [1,2], (1,2), 1(엄밀히 말하면 0이 아니면 참이다) 
  * 뭔가가 있으면 참

* 거짓: "", [ ], ( ), 0, None 
  * 뭔가 없으면 거짓

* explicit programming(조건문): 모든 조건, 상황을 명시해주는
  * if문으로 모든 조건을 일일이 명시해줘야 하는


##### 조건문
if 고양이가 나타나면:           if 조건:
    브레이크를 밟는다           들여쓰기=종속문=조건문에 종속
    크락션을 울린다             (들여쓰기 하지 않으면 위의 조건 문장과 상관없는 문장으로 본다)
달린다                          조건과는 별개의 문장, 고양이가 나타나든 말든 관계없이 수행하는 것

if 강아지가 나타나면:
    브레이크를 밟는다
    크락션을 울린다

*  implicit programming: 명시를 하지 않았지만, 조건을 다 주지 않아도 상황에 맞춰서 판단을 하는 것이 가능 
   *  if문으로 명시해주지 않는 상황에도 판단을 할 수 있는
   *  ai의 힘, 자율주행 가능
   *  드론시대: 
       택배(택배창고 -> a,b,c,d,e -> 택배창고):120가지 경로,어떤 순서로 배달해야 가장 빠르게 적은 비용으로 배달할 수 있을까라는 이슈.
       한계 존재. 50명에게 배달하려면 50팩토리얼 경우의 수 존재. 아직 컴퓨터도 50!은 계산하기 힘들어. 일반적 프로그래밍으론 안 된다.

```python
x=10
if x==10:
    print('10입니다')
    print("5보다 큽니다")
print("문장을 수행합니다")


x=3
if x==10:
    print('10입니다')
    print("5보다 큽니다")
print("문장을 수행합니다")

x=3
if x!=10:
    print('10입니다')
    print("5보다 큽니다")
print("문장을 수행합니다")


# 참: "test", [1,2], (1,2), 1
# 거짓: "", [ ], ( ), 0, None 

if "test":
    print("수행합니다")

    
if None:
    print("수행합니다")
    
    
x=10
if x ==10:
    print("안녕")
    if x%2 == 0:
        print("하세요")
# 안녕
# 하세요 
        
x=5
if x==5:
    print("x는")
print("5입니다.")
# x는
# 5입니다.


x=5
if x >=3:
    print("3이상")
    if x<5:
        print("5미만")
print("입니다")
# 3이상
# 입니다


if []: # 거짓이므로 else 문장 수행
    print("참")
else:
    print("거짓")
# 거짓
    

if [1,2]: # 참이므로 else 문장 수행 X
    print("참")
else:
    print("거짓")
# 참
    
if None: # 거짓이므로 else 문장 수행
    print("참")
else:
    print("거짓")
# 거짓
```

```python
# bool
bool(0)
bool(10)
bool('Python')
bool('') # False
```

```python
a=[1,2,3]
if a:  # a list가 오게 되는 것 => True: 빈 리스트 아니므로/ False: 빈 리스트
    print(a.pop())  # 중첩 함수(함수 안에 함수): 안에 있는 함수부터 실행. pop: 마지막 숫자 꺼내는
a # [1, 2]


a=[1,2,3]
while a:  # while(~동안), a변수 값이 참인 동안에 (들여쓰기 되어 있는 문장) 계속 반복해라
    print(a.pop())
# 3
# 2
# 1
```

```python
# 반복문
for i in range(10):
    print(i)

for i in range(10):
    print('hi')
    
    
# 문제: 데이터 입력을 받아서 10보다 작으면 "10보다 작아요" 그렇지 않으면 "10보다 커요"
a = int(input())
if a < 10:
    print("10보다 작아요")
else:
    print("10보다 커요")
```


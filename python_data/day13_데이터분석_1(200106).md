#### day13_데이터분석_1(200106)

#### Numpy, Pandas 병행
- Numpy(-> 데이터 전처리): 수치연산에 최적화되어 있어, 전처리에 용이
- Pandas(-> 데이터 분석):데이터 분석하는 강력한 tool

##### matplotlib, seavorn 시각화

- 전처리: 결측치, 표준화/정규화
- 정규화: 각 국어점수-최소/국어점수의 최대-최소 => 0~1
- 표준화: 평균-0, 표준편차-1
- 각 국어점수- 평균 / 국어점수 표준편차
- 원핫인코딩:100000, 010000, 001000,... data가 큰 경우에는 적합하지 않음(비효율적)
            A       B       C     D  E  F
* 문장 추출 -> 단어(5개) 추출 -> 원핫인코딩
        
        * 국어
          영어
          수학
          과학
          윤리

- 문장 추출 -> 단어(5개) 추출 -> 밀집벡터(워드2벡터)
    - 워드2벡터=word2vec): 단어들을 수치형태로 인베딩하는 것으로 차원축소 효과 + 벡터 공간에 나타남
        - 두가지 방법
            - CBOW(Continuous Bag of Words): 단어 주변들을 보고 가운데 단어를 모델로 나타내는 것
            - Skip-gram
    - 국어 [0.2, 0.7]
    - 수학 [0.1, 0.3]
    - 

##### Numpy(전처리)

- 수치연산에 최적화된 도구

- 넘파이 배열: 넘파이에서 사용하는 배열로 적은 양의 메모리로 빠르게 처리
    - 리스트: 리스트에 저장된 자료구조 속도 느림, 메모리 많이 차지. 잡다한 데이터 다 들어갈 수 있음
    - **배열(array)**: 속도빠름, 메모리 적게 차지
    
- 넘파이 배열과 리스트의 차이점
    - 배열은 모두 같은 자료형으로만 저장 가능. 서로 다른 데이터 담을 수 있는 리스트와는 다름.
    - 배열은 원소의 개수 변경 못함(크기 정해지면 변경 불가능: 리스트에서 쓰던 append X)
    - 배열은 파이썬에서 제공하지 않아 파이썬에 존재 X 
    - 파이썬 환경에서 Numpy 패키지를 활용하여 배열을 사용할 수 있음
    
 - **넘파이**란?
   
     - 수치해석용 패키지, 다차원 배열 구조 지원됨.
     
     - 벡터, 행렬을 사용하는 선형대수 계산시 사용
       
         - 넘파이를 사용한다는 것을 벡터, 행렬 사용하겠다는 것으로 이해하면 됨
         
     - 넘파이 배열 연산 빠름(벡터화 연산이기 때문에)
     
         
     
     - 100*100 크기의 이미지(픽셀: 10000개)
         0~255 사이의 gray sclae은 몇 차원?
         => 픽셀 10000개 == 차원이 1000개 픽셀하나가 차원이다.(픽셀 하나를 '축'으로 생각하면 됨) 
         ==> 10000차원
     

```python
# 대괋호 1개면 1차원, [] 2개면 2차원, []개면 3차원,...

# 1차원 배열
import numpy
ar=numpy.array([0,1,2,3,4])  # 리스트 [0,1,2,3,4]를 1차원 배열로 변환한 것
ar  # [0 1 2 3 4]
type(ar) # numpy.ndarray -> n차원 배열
```

- 시간/공간 복잡도
- 시간복잡도: 연산 결과가 나오기까지 수행되는 라인의 수로 CPU와 관련.
  - ex. 위의 코드 10번 반복 -> 10 
  - => 시간복잡도 작을 수록 좋은 프로그램이다. 즉 효율적인 알고리즘이라고 할 수 있다.
- 공간복잡도: MEM(메모리)와 비교
  - 공간복잡도 시간복잡도에 비해 언급 X. 메모리 차지하는 공간복잡도 낮을수록 효율적.

```python
# 시간복잡도 비교
# 1
data = list(range(0,101))
sum = 0
for d in data:
    sum += d   # O(n)
print(sum)

# 2
sum=0
d=100
print(d*(d+1)/2)  # O(1)  
==> 연산 횟수가 고정된 경우, 항상 5번, 100번 반복하는 경우도 O(1)로 표현
```

```python
# data에 저장된 모든 값들에 대해 2배로 해서 배열로 저장하기

# for문 사용
data = list(range(0,10))
d=[]
for i in data:
    d.append(i*2)    
print (d)

data=numpy.array([d])
data
type(data)


# 벡터화 연산으로 코드 짜기
data = list(range(0,10))
import numpy as np
x=np.array(data)
x*2 
==> array([ 0,  2,  4,  6,  8, 10, 12, 14, 16, 18])
# 벡터화 연산: for문 사용 x, 한번의 연산으로 해결 가능
```

* array로 연산하기(=벡터화 연산)

```python
# array로 연산하기=벡터화 연산
# array: 요소간 연산 가능(=element wise ~)
a=np.array([1,2,3])
b=np.array([4,5,6])
2*a+b 
==> [ 6  9 12] <- 요소 간 곱셈 및 덧셈 가능

# list로 연산하기
a2=[1,2,3]
b2=[4,5,6]
2*a2+b2 
==> [1, 2, 3, 1, 2, 3, 4, 5, 6] <- append형식으로 연산됨


# 논리연산
# 리스트
a2==2 
==> False
# 배열
a==2  
==> array([False,  True, False]) <- 각각의 요소에 논리연산 수행해서 결과 출력


# 비교연산
# 리스트
a2>2 
==> '>' not supported between instances of 'list' and 'int'
# 배열
a>2  
==> array([False, False,  True]) <- 각 요소에 대해서 비교연산 수행
```

* 2차원 배열(행렬, matrix): [[]] -대괄호 2개로 묶어서 표현
  * 가로줄: 행, 세로줄: 열
    * 행:바깥쪽 리스트 길이, 세로 크기
      * 행의 개수 구하는 법:len(m) 
    * 열:안쪽 리스트 길이, 가로 크기
      * 열의 개수 구하는 법: 행 추출한 후 행에 대해 len구함.

```python
# 2차원 배열: 리스트의 리스트 = 2개의 리스트를 리스트로 묶어줌
m=np.array([[0,1,2],[3,4,5]]) 
m
# m은 2행 3열 배열
array([[0, 1, 2],
      [3, 4, 5]])

# 행의 개수 구하는 법
len(m) 
==> 행의 개수: 2
# 열의 개수 구하는 법: 행 추출한 후 행에 대해 len구하면 열의 개수 구할 수 있다
len(m[0]) 
==> 열의 개수: 3
```

* 3차원 배열: 리스트의 리스트의 리스트

```python
m=np.array([[[1,2,3,4],     # [[]]: 1행
         [5,6,7,8],
         [9,10,11,12]],
         [[31,2,3,4],     # [[]]: 2행
         [35,6,7,8],
         [39,10,11,12]]])

# 2행 3열 4깊이/(면)
# 2*3*4(=2 by 3 by 4)
len(m) # 2 <- 행의 개수
len(m[0]) # 3 <- 열의 개수
len(m[0][0]) # 4 <- 깊이

print(m.ndim) # 3 <- 3차원
print(m.shape) # (2, 3, 4)
```

* 배열의 차원 쉽게 구하는 법: 함수 사용
  * ndim:배열의 차원구하는 함수
  * shape: 배열의 크기구하는 함수

```python
# 1차원
a = np.array([4,5,6])
a.ndim # 1 <- 배열의 차원
a.shape # (3,) <- 배열의 크기

# 2차원
m=np.array([[0,1,2],[3,4,5]])
m.ndim # 2
m.shape # (2, 3): 2행 3열
```



##### Numpy slicing

데이터 쪼갤 일 많아, 슬라이싱-인덱싱 잘 해야

* slicing: 데이터 여러개를 참조

```python
ar=np.array([[1,2,3,4],[5,6,7,8]])
ar
ar[0]   # 첫번째 행 전체: array([1, 2, 3, 4])
ar[0,:] # 첫번째 행 전체: array([1, 2, 3, 4])
ar[:,1] # 두번쨰 열 전체: array([2, 6])

ar[1,1:] # 두번째 행에서 두번째 열부터 마지막까지: array([6, 7, 8])

# [1,2,5,6] 추출되도록 슬라이싱
ar[:,0:2]
ar[:,:2]
ar[:2,:2]
```

* indexing: 데이터 1개를 참조

```python
ar=np.array([0,1,2])
ar[1] # 1 추출
ar[-1] # 1 추출


ar=np.array([[1,2,3,4],[5,6,7,8]])
# 1 추출
ar[0][0] # 1 
# 다차원 배열에서는 컴마로 접근 가능
ar[0,0] # 1 
ar[0,1] # 2 

# 6추출, 두번째 행의 두번째 열
ar[1][1]
ar[1,1] 
ar[-1][1]
ar[-1,1]
ar[-1][-3]
ar[-1,-3]
```

#### boolean 인덱싱

* [boolean indexing](https://nittaku.tistory.com/107) 참고
* 조건에 대해 만족하는 값을 추출
  * 조건에 대한 결과가 참, 거짓으로 나옴. 참인 조건에 해당하는 자료를 추출.

```python
## 불린 참조 ##

ar = np.array([2,3,4,5])
bidx = np.array([True,True,False,True])
# 인덱스 참조하기 위해 논리갑 가진 값을 배열에 주는 것
ar[bidx] # => array([2, 3, 5])
ar != 4 # => array([ True,  True, False,  True]) ==> 리스트였다면 에러나오는 결과
ar[ar != 4] # array([2, 3, 5])

# ar에 요소값이 짝수인 것들만 추출
ar%2==0 # ==> array([ True, False,  True, False])
ar[ar%2==0] # ==> array([2, 4])

# ar요소값이 3보다 큰 값들만 추출
ar>3 # ==> array([False, False,  True,  True])
ar[ar>3] # ==> array([4, 5])
```

* 정수 참조 추출

```python
# 정수 참조 추출

ar = np.array([2,3,4,5])
idx=np.array([0,3])
ar[idx] # ==> array([2, 5]) : idx가 index 번호 역할

idx=np.array([0,0,1,1])
ar[idx] # ==> array([2, 2, 3, 3])

ar=np.array([[1,2,3,4],[5,6,7,8]])


연습문제
[[1,4],
[[5,8]]] 추출하기

ar[:,[0,3]]
ar[:,[True,False,False,True]] # 불린참조

ar[:] 
==> ar 전체 행: ,가 없으면 행을 말함. 컴마없으면 행,열을 다 표현하는 것
ar 
==> ar 배열 전체
ar[:,:] 
==> 전체 행 전체 열

ar=np.array([[1,2,3,4],[5,6,7,8]])
ar[,:] 
==> invalid syntax:추출해야하는 행 부분 몰라서 에러난 것
    
    
    
ar=np.array([[1,2,3,4],
             [15,16,17,18],
             [25,26,27,28],
             [35,36,37,38]])
ar[2,:]
ar[[2,0,-1],:]  
# [2,0,-1]: 참조하고자 하는 행 의미. 1개 이상이면 []로 묶어줘야함.
```



#### Pandas

- 행과 열로 구성된 데이터가 대부분. 분석해야할 데이터 대부분이 행과 열로 구성. 
    - 행과 열 데이터 array형태로 읽어오게 된다.
- 원데이터: csv, tsv(tab으루 구분되어진 text문서), txt, xls, xlsx, jason, xml,...
- Pandas: 원데이터를 데이터프레임으로 읽어서 분석하는 것으로 가장 일반적인 분석방법
    - 데이터프레임
        - 자료구조(=자료 저장,관리하는 방법) 판다스에서 사용되어지는 자료구조 중 하나
        - 엑셀 시트와 비슷
- Numpy: 원데이터를 다차원배열로 읽어서 처리
- 판다스 공부하는 법
    - https://pandas.pydata.org/ > Release > pdf 문서
- 행인덱스: 맨 왼쪽에 있는 열
- 열인덱스: 인덱스 이름으로 header default가 있어, 첫번째 줄을 무조건 header로
- 데이터: 행,열 인덱스 제외한 부분

```python
""" 
데이터 만들기: 메모장에 -> test_csv.csv로 저장
ID,LAST_NAME,AGE
1,KIM,25
2,LEE,22
3,PARK,33
4,CHOI,24
5,CHO,30
"""

import pandas as pd
csvTest=pd.read_csv("test_csv.csv") 
# csv: 자동으로 ,로 구분하여 지도록 설계
type(csvTest) 
# pandas.core.frame.DataFrame  -> DataFrame: class
# pandas 안에 core 안에 frame 안에 DataFrame으로 이해하면 된다.
csvTest

# shape함수
csvTest.shape # (5, 3) : 튜플
csvTest.shape[0] # 5: 행
csvTest.shape[1] # 3: 열
```

```python
"""
메모장 > ctrl+H: , 한번에 |로 바꿔서 test_text.txt 다른 이름으로 저장
test_text.txt
구분자: |
"""
text=pd.read_csv("test_text.txt")
text
text.shape 
==> (5, 1): 컴마로 구분이 안 되어 있어 열이 하나

# 구분자 옵션 추가
text=pd.read_csv("test_text.txt", sep="|")
text
text.shape 
==> (5, 3): 정상적으로 읽어짐
```

